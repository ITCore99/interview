/**
 * 香槟塔
 * 把玻璃杯白城一个金字塔的形状，其中第一层放置一个杯子第二层放置两个杯子 一次类推到第100层
 * 从顶层开始到香槟，当顶部的杯子满了之后任何溢出的香槟都会等量的流到左右两侧的杯子中。当左右的杯子也满了之后会等量到他们左右的杯子中一次类推
 * 现在当倾倒了非负正数杯香槟之后，返回第i行j列玻璃杯所盛放的香槟占玻璃杯容积的比例(i,j都是存0开始)
 * 分析：
 *          1
 *        2   3
 *      4    5    6
 *  ....
 * 当1中的满了之后会均匀的溢出到 2 3中当2中满了之后就会溢出到4 5中 3满了之后机会溢出到5 6中
 * 假设我们用一个二维数组进行描述这个情况 1([0,0]) 满了之后溢出到 2([1,0]) 3([1,1]) 2([1,0])满了之后溢出到 4([2,0]) 5([2,1]) 3([1,1])满了之后溢出到 5([2,1]) 6([2,2]) 依次
 * 进行类推 我们仔细观察数据发现 一个杯子满了之后能溢出的杯子的坐标是存在规律的假设此杯子坐标为(x,y)那么所能溢出的杯子坐标是 左杯子([x+1, y]) 右边杯子([x+1, y+1])
 * 
 */

/**
 * 获取容量
 * @param {*} cups 倾倒的香槟杯数
 * @param {*} x  行数
 * @param {*} y  列数
 */
function getCapacity(cups, r, l) {
  const cupsArr = new Array(100)  // 创建一个金字塔100*100矩阵用于保存当前位置杯子中盛的香槟数量
  for(i = 0; i < 100; i++) {
    cupsArr[i] = new Array(100).fill(0)
  }
  cupsArr[0][0] = cups // 设置顶部杯子容量
  for(let i = 0; i < 100; i++) {
    for(let j = 0; j <= i; j++) { // j <= i是因为每一行只能防止i个杯子
      const overflowNum = (cupsArr[i][j] - 1) / 2 
      if(overflowNum > 0) { // 说明需要溢出
        cupsArr[i+1][j] += overflowNum // 左边杯子
        cupsArr[i+1][j+1] += overflowNum // 右边杯子
      }
    }
  }
  return Math.min(cupsArr[r][l],1)
}

console.log('杯子容量', getCapacity(5,2,2))
