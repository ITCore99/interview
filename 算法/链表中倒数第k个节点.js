/**
 * 链表倒数第k个节点
 * 输入一个链表，输出链表中倒数第K个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是最后一个节点。
 * 进阶: 时间复杂度 O(n) 空间复杂度 O(1)
 * 例如：一个链表有6个节点 从头结点开始，他们的值一次是 1,2,3,4,5,6 这个节点的倒数第三个节点就是4
 * 注意：我们需要知道找出倒数第k节点 正着数第len - k + 1个节点
 * 解法1: 先遍历链表将每一个节点的位置信息和节点保存到一个map空间中同时获取到链表的长度n 那么我们能计算出n-k+1处的节点 就是题目中所需要的节点 空间复杂度O(n) 不符合
 * 解法2: 不进行开辟额外的空间 首先遍历获取到链表的长度n 在进行一次遍历获取n-k+1上位置的节点 就是题目要求节点 时间复杂度O(n) 空间复杂度O(1) 但是遍历了两次能否一次
 * 解法3: 要求只遍历一次可以实现 使用双指针方式 定义指针p1, p2都指向都头部 现将p1移动k-1次 是的两个指针之间的差值正好是倒数差值。开始遍历链表p1,p2每次只移动一个数当p1移动到链表
 * 尾部那么p2所指的位置就是倒数第k各节点。
 */


/**
 * 获取链表中倒数第k个节点
 */
function getReciprocalNode(head, k){
 if(!head || k <= 0) return null
 let p1 = head
 let p2 = head
 for(let i = 1; i < k; i++) { // 先进行移动p1指针使其与p2指针产生固定差距
    p1 = p1.next
 }
 while(p1.next) { // 整体遍历移动
  p1 = p1.next
  p2 = p2.next
 }
 return p2
}

// 测试
const head = {
  value: 11,
  next: {
    value: 9,
    next: {
      value: 8,
      next: {
        value: 5,
        next: {
          value: 4,
          next: {
            value: 1,
            next: null
          }
        }
      }
    }
  }
}
console.log(getReciprocalNode(head, 3))